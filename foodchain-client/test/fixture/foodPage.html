<html>
  <head>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="white">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
    <script src="../../dist/external/cbor.js" type="text/javascript"></script>
    <script src="../../dist/external/elliptic.min.js" type="text/javascript"></script>
    <script src="../../dist/external/protobuf.min.js" type="text/javascript"></script>
    <script src="../../dist/external/jss.min.js"></script>
    <script src="../../dist/external/jss-nested.min.js"></script>


    <style>
      body {
        background-color: whitesmoke;
      }

      .searchInput {
        width: 100%;
        height: 42px;
        padding-left: 10px;
        font-size: 24px;
        font-family: sans-serif;
        margin-bottom: 10px;
        border: none;
        outline:none;
      }
      
      .searchInput::placeholder {
        padding-left: 10px;
        font-size: 16px;
        font-weight: 100;
        color: lightgrey;
      }

      .signButton {
        height: 30px;
        width: 60px;
        position: relative;
        left: calc(100% - 60px);
        line-height:30px;
        text-align: center;
        background-color: white;
        margin-top: 10px;
        margin-bottom: 20px;
        font-family: sans-serif;
        color: lightgrey;
      }

      .signButton.active {
        color: black
      }

      .submitButton {
        height: 30px;
        width: 60px;
        position: relative;
        left: calc(100% - 60px);
        line-height:30px;
        text-align: center;
        background-color: white;
        margin-top: 10px;
        margin-bottom: 20px;
        font-family: sans-serif;
        color: black;
      }

    </style>
  </head>
  <body>
    <script type="module">
      window.serverAddress = ''

      import { sha256Hex } from '../../src/hashing.js'
      window.sha256Hex = sha256Hex

      import nutrientTable from '../../src/nutrientTable.js'
      customElements.define('nutrient-table', nutrientTable)

      import foodEditor from '../../src/foodEditor.js'
      customElements.define('food-editor', foodEditor)

      import foodItem from '../../src/foodItem.js'
      customElements.define('food-item', foodItem)

      import { generateNewKey, importKey, Sawtooth } from '../../src/sawtooth.js'

      let key
      try {
        key = importKey()
      } catch (error) {
        if (error.message === 'there is no key') key = generateNewKey()
      }

      window.sawtooth = new Sawtooth(key)

      window.worker = new Worker('../../src/indexedDBWorker.js')
      window.NETWorker = new Worker('../../src/NETWorker.js')
      window.NameResolver = new Worker('../../src/NameResolver.js')

    </script>

    <script type='module'>

      function populateFoodPage (data) {
        data.forEach((d) => {
          let foodItem = document.createElement('food-item')
          foodItem.init(d, 'DATABASE')

          switch (d.status) {
            case 'SIGNED':
              foodItem.setAttribute('data-status', 'SIGNED')
              document.body.insertBefore(foodItem, submitButton)
              signedFoodData.push(d)

              break
            case 'SUBMITTED':
              foodItem.setAttribute('data-status', 'SUBMITTED')
              foodItem.confirmSubmission = confirmSubmission.bind(foodItem)
              document.body.appendChild(foodItem)
              submittedFoodData.push(d)
              
              break

            case 'COMMITTED':
              foodItem.setAttribute('data-status', 'COMMITTED')
              document.body.appendChild(foodItem)
              committedFood.push(foodItem)

              break
          }
        })

        if (data.filter(d => d.status === 'SIGNED').length > 0) submitButton.hidden = false
      }

      function clearEditor () {
        foodEditor.nutrientTable.shadow.querySelectorAll('li:not(.constituentSelector)').forEach((n) => {
          n.remove()
        })
        foodEditor.nameInput.value = ''
        foodEditor.addressNameState
        foodEditor.nutrientTable.selector.hidden = true
      }

      function appendNewFood (data) {
        let foodItem = document.createElement('food-item')
        foodItem.setAttribute('data-status', 'SIGNED')
        foodItem.init(data, 'DATABASE')
        document.body.insertBefore(foodItem, submitButton)
        submitButton.hidden = false
      }

      function appendSignedFoodAsSubmitted(data) {
        let signedItems = document.querySelectorAll('food-item[data-status="SIGNED"]')
        signedItems.forEach((i) => {
          i.setAttribute('data-status', 'SUBMITTED')
          i.confirmSubmission = confirmSubmission.bind(i)
          document.body.appendChild(i)
        })

        submitButton.hidden = true
      }

      function appendSubmittedFoodAsCommitted(data) {
        document.querySelectorAll('food-item[data-status="SUBMITTED"]')
        .forEach((n) => {
          if (n.name.textContent === data[0].name) {
            n.setAttribute('data-status', 'COMMITTED')
            document.body.appendChild(n)
          }
        })
      }

      worker.onmessage = (e) => {
        switch (e.data[0]) {
          case 'AllFoodItems':
            populateFoodPage(e.data[1])
            break

          case 'FoodSubmitted':
            appendSignedFoodAsSubmitted(e.data[1])
            signedFoodData = []
            break

          case 'FoodCommitted':
            appendSubmittedFoodAsCommitted(e.data[1])
            submittedFoodData = submittedFoodData.filter((d) => d.batchID !== e.data[1][0].batchID)
            break

          case 'FavouritesMerged':
            updateFavouriteDOM(e.data[1])
            break
        }
      }

      NETWorker.onmessage = (e) => {
        switch (e.data[0]) {
          case 'BatchesSubmitted':
            let signedItemsUpdate = signedFoodData.map((d) => {
              d.status = 'SUBMITTED'
              d.batchID = e.data[1]
              return d
            })
            submittedFoodData = submittedFoodData.concat(signedItemsUpdate)
            worker.postMessage(['UpdateFoodItems', signedItemsUpdate])
            break

          case 'MyAddressStateFetched':
            let favourites = e.data[1].favourites
            if (favourites) worker.postMessage(['MergeWithFavourites', favourites])
            break

          case 'SubmissionConfirmed':
            let submittedItemsUpdate = submittedFoodData.filter((d) => {
              return d.batchID === e.data[1] 
            })
            .map((d) => {
              d.status = 'COMMITTED'
              return d
            })

            worker.postMessage(['UpdateFoodItems', submittedItemsUpdate])
            break
        }
      }

      worker.postMessage(['GetAllFoodItems'])

      window.committedFood = []
      window.signedFoodData = []
      window.submittedFoodData = []

      document.body.addEventListener('FoodSigned', (e) => {
        clearEditor()
        appendNewFood(e.detail)
        signedFoodData.push(e.detail)
      }, true)

      const confirmSubmission = function () {
        NETWorker.postMessage(['ConfirmSubmission', this.data.batchID])
      }

      const SubmitButton = () => {
        let submitButton = document.createElement('div')
        submitButton.classList.add('submitButton')
        submitButton.hidden = true
        submitButton.textContent = 'Submit'

        submitButton.addEventListener('click', (event) => {
          let transactions = signedFoodData.map((d) => d.transaction )
          return sawtooth.buildBatch(transactions)
          .then((batch) => {
            let batchListBytes = sawtooth.encodeBatchList([batch])
            NETWorker.postMessage(['SubmitBatches', batchListBytes])
          })
          .catch((error) => {
            console.log(error)
          })
        })

        return submitButton
      }

      const FoodSigning = async function() {
        if (this.classList.contains('active')) {
          let data = await foodEditor.compileData() 
          let worker = new Worker('../../src/indexedDBWorker.js')
          worker.postMessage(['InsertNewFood', [data]])

          worker.onmessage = (e) => {
            let foodSigned = new CustomEvent('FoodSigned', {detail: e.data[1][0]})
            this.dispatchEvent(foodSigned)
          }

          worker.onerror = (e) => {
            worker.terminate()
          }
        }
      }

      const SignButton = () => {
        let signButton = document.createElement('div')
        signButton.classList.add('signButton')
        signButton.hidden = true
        signButton.textContent = 'Sign'
        signButton.addEventListener('click', FoodSigning.bind(signButton))

        return signButton
      }

// initialization steps

      let searchInput = document.createElement('input')
      searchInput.classList.value = 'searchInput'
      searchInput.setAttribute('placeholder', 'Search Food Here...')
      searchInput.addEventListener('keyup', (event) => {
        let name = event.target.value
        switch (name) {
          case '' :
            committedFood.forEach((e) => { e.hidden = false })
            break
          default :
          committedFood.filter((e) => !new RegExp(name).test(e.name.textContent))
          .forEach((e) => { e.hidden = true})
        }
      })
      document.body.append(searchInput)

      window.foodEditor = document.createElement('food-editor')
      document.body.appendChild(foodEditor)
      document.addEventListener('NameChanged', (e) => {
        signButton.hidden = (e.detail.isEmpty) ? true : false
        signButton.classList.remove('active')
        foodEditor.addressState.textContent = ''

        let name = e.detail.name

        let AddressStateHandler = function (e) {
          if (e.data[1] === name) NameResolver.removeEventListener(e.type, AddressStateHandler)

          switch (e.data[0]) {
            case 'AddressStateFetched':
              if (e.data[2] === null) {
                foodEditor.addressState.textContent = 'new food'
                signButton.classList.add('active')
              }
              break

          }
        }

        if (!e.detail.isEmpty) {
          NameResolver.addEventListener('message', AddressStateHandler)
          NameResolver.postMessage([e.detail.name, true])
        }
      }, true)

      window.signButton = SignButton()
      document.body.appendChild(signButton)

      let submitButton = SubmitButton()
      document.body.appendChild(submitButton)

// initialization steps

      function updateFavouriteDOM(data) {
        let add = data[0]
        let remove = data[1]
        add.forEach((d) => {
          let foodItem = document.createElement('food-item')
          foodItem.init(d, 'BLOCK')
          foodItem.setAttribute('data-status', 'COMMITTED')
          document.body.appendChild(foodItem)
        })

        remove.forEach((n) => {
          document.querySelectorAll('food-item[data-status="COMMITTED"]').forEach((e) => {
            if (e.name.textContent === n) e.remove()
          })
        })
      }

      function syncWithAddress () {
        let myAddress = '100000' + sawtooth.key.getPublic().encodeCompressed('hex').substr(2,64)
        NETWorker.postMessage(['FetchMyAddressState', myAddress])
      }

      syncWithAddress()

    </script>
  </body>
</html>

